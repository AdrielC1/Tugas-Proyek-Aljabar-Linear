import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe

# ===================================================================
# BAGIAN 1 & 2: MENCARI EIGEN & VISUALISASI (Tugas 6.1, 6.2)
# ===================================================================
print("--- ðŸ”µ Bagian 1 & 2: Implementasi & Visualisasi ---")

# 1. Definisikan Matriks Transformasi (Tugas 6.1)
# Kita pakai matriks 'shear' (geser)
A = np.array([
    [1, 1],
    [0, 2]
])

print(f"Matriks A:\n{A}\n")

# 2. Cari Nilai Eigen dan Vektor Eigen (Tugas 6.1)
# Ini adalah implementasi profesionalnya
nilai_eigen, vektor_eigen_cols = np.linalg.eig(A)

lambda1 = nilai_eigen[0]
lambda2 = nilai_eigen[1]

# Vektor eigen dikembalikan sebagai KOLOM-KOLOM
v1 = vektor_eigen_cols[:, 0]
v2 = vektor_eigen_cols[:, 1]

print(f"Nilai Eigen (lambda): {nilai_eigen}")
print(f"Vektor Eigen (kolom v1, v2):\n{vektor_eigen_cols}\n")
print(f"  Lambda 1 = {lambda1:.2f}, Vektor v1 = {v1}")
print(f"  Lambda 2 = {lambda2:.2f}, Vektor v2 = {v2}\n")

# 3. Siapkan Vektor untuk Visualisasi (Tugas 6.2)
# v1 dan v2 adalah vektor eigen.
# Mari kita buat 1 vektor "normal" (bukan eigen) untuk perbandingan
v_normal = np.array([1, 1])

# 4. Terapkan Transformasi A ke semua vektor
# T(v) = A . v
T_v1 = A.dot(v1)
T_v2 = A.dot(v2)
T_v_normal = A.dot(v_normal)

# 5. Cek Pembuktian (A.v == lambda * v)
print("Pembuktian A.v = lambda * v:")
print(f"  A . v1     = {T_v1}")
print(f"  lambda1 * v1 = {lambda1 * v1}")
print(f"  A . v2     = {T_v2}")
print(f"  lambda2 * v2 = {lambda2 * v2}\n")
# Anda akan lihat bahwa hasilnya SAMA!

# 6. Visualisasi (Tugas 6.2)
print("Menampilkan plot visualisasi...")
fig, ax = plt.subplots(figsize=(10, 10))
ax.set_aspect('equal')
ax.grid(True)
ax.set_title("Visualisasi Efek Vektor Eigen")
ax.set_xlabel("Sumbu X")
ax.set_ylabel("Sumbu Y")

# Tarik garis bantu
ax.axhline(0, color='grey', lw=0.5)
ax.axvline(0, color='grey', lw=0.5)

# Fungsi helper untuk plot
def plot_vektor(vec, color, label, linestyle='-'):
    ax.quiver(0, 0, vec[0], vec[1], 
              color=color, 
              angles='xy', scale_units='xy', scale=1, 
              label=label, 
              path_effects=[pe.withStroke(linewidth=2.5, foreground='white')],
              zorder=3)
    # Plot garis tak terhingga
    if label.startswith("Vektor"):
        ax.plot([0, vec[0]*10], [0, vec[1]*10], color=color, ls=':', zorder=2)
        ax.plot([0, vec[0]*-10], [0, vec[1]*-10], color=color, ls=':', zorder=2)

# Plot Vektor Eigen (v1) dan transformasinya
plot_vektor(v1, 'b', f"Vektor Eigen v1 (lambda={lambda1:.1f})")
plot_vektor(T_v1, 'b', "T(v1) - TETAP DI JALUR", linestyle='--')

# Plot Vektor Eigen (v2) dan transformasinya
plot_vektor(v2, 'r', f"Vektor Eigen v2 (lambda={lambda2:.1f})")
plot_vektor(T_v2, 'r', "T(v2) - TETAP DI JALUR", linestyle='--')

# Plot Vektor Normal (v_normal) dan transformasinya
plot_vektor(v_normal, 'g', "Vektor Normal v_normal")
plot_vektor(T_v_normal, 'g', "T(v_normal) - BERUBAH ARAH", linestyle='--')

# Atur batas plot dan legenda
ax.set_xlim(-2, 4)
ax.set_ylim(-1, 3)
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
fig.subplots_adjust(right=0.7)
plt.show()


# ===================================================================
# BAGIAN 3: APLIKASI KASUS NYATA (Tugas 6.3)
# ===================================================================
print("\n--- ðŸŸ¢ Bagian 3: Aplikasi (Analisis Stabilitas) ---")

# Skenario: "Markov Chain" untuk pangsa pasar (stabilitas sistem)
# Ada 2 layanan: A dan B
# - Setiap bulan, A mempertahankan 90% pelanggannya, 10% pindah ke B.
# - Setiap bulan, B mempertahankan 80% pelanggannya, 20% pindah ke A.

# Matriks Transisi P (kolom = DARI, baris = KE)
#        (Dari A)  (Dari B)
# (Ke A)    0.9       0.2
# (Ke B)    0.1       0.8
P = np.array([
    [0.9, 0.2],
    [0.1, 0.8]
])

print(f"Matriks Transisi (P):\n{P}\n")

# Distribusi stabil (stable state) adalah Vektor Eigen
# yang memiliki Nilai Eigen = 1.
# Mari kita buktikan!
p_vals, p_vecs = np.linalg.eig(P)

print(f"Nilai Eigen P: {p_vals}")
print(f"Vektor Eigen P:\n{p_vecs}\n")

# Temukan vektor yang nilai eigen-nya ~ 1.0
# (Kita gunakan np.argmin untuk menemukan v yang lambda-nya paling dekat ke 1)
indeks_stabil = np.argmin(np.abs(p_vals - 1.0))
vektor_stabil = p_vecs[:, indeks_stabil]

print(f"Vektor stabil mentah (v_stabil): {vektor_stabil}")

# Vektor ini [x, y] mewakili rasio. Kita perlu menormalisasinya
# agar x + y = 1 (total pangsa pasar = 100%)
vektor_stabil_normal = vektor_stabil / np.sum(vektor_stabil)

# (Hasilnya mungkin negatif [-0.89, -0.44], itu tidak masalah,
# karena arah [-1, -1] sama dengan [1, 1]. Kita ambil nilai absolut)
vektor_stabil_final = np.abs(vektor_stabil_normal)

print(f"\nDistribusi Stabil (Normalisasi): {vektor_stabil_final}")
print(f"Artinya, sistem akan stabil pada:")
print(f"  Layanan A: {vektor_stabil_final[0]:.1%}")
print(f"  Layanan B: {vektor_stabil_final[1]:.1%}")

# Mari kita buktikan. Mulai dengan 50/50
status_awal = np.array([0.5, 0.5]) # 50% A, 50% B
print(f"\nJika mulai dari 50/50:")

status_bln_1 = P.dot(status_awal)
print(f"Bulan 1: {status_bln_1}") # [0.55, 0.45]

status_bln_2 = P.dot(status_bln_1)
print(f"Bulan 2: {status_bln_2}") # [0.585, 0.415]

# Setelah 50 bulan...
status_final = status_awal
for _ in range(50):
    status_final = P.dot(status_final)

print(f"Bulan 50: {status_final}")
print("Hasilnya sama dengan Vektor Eigen kita!")
